---
layout: post
title: django笔记
date: 2021-12-26 09:53 +0800
---

# 基础
1. 安装django以后就可以用`django-admin`
   1. 创建project: `django-admin startproject HelloWorld`
   2. 创建app: ``
2. 引入当前目录的内容: `from . import views`
3. 安装xmlsec失败，先安装依赖: `brew install libxml2 libxmlsec1 pkg-config` , https://blog.csdn.net/yuyexiaohan/article/details/107145624
4. Disallowed Host: `Invalid HTTP_HOST header: '127.0.0.1:8000'. You may need to add '127.0.0.1' to ALLOWED_HOSTS`
   1. 修改settings.py->'ALLOWED_HOSTS'
5. django admin app: `'django.contrib.admin'`
6. django admin后台地址: `http://localhost:8000/admin`
7. django admin的默认账号,没有。 需要通过命令创建: `python manage.py createsuperuser`
8. 给django manager添加命令[Django : How can I see a list of urlpatterns?](https://stackoverflow.com/a/65570954)
8. django admin列出所有的urls(rails routes等价物), 需要装django-extension:
   1. `pip install django-extensions`
   2. 安装app, settings.py->INSTALLED_APPS, 添加`'django_extensions',`
9. Linkedin登录:
   1.  [官方django例子](https://github.com/python-social-auth/social-examples/tree/master/example-django), 需要把抛错的app删除，然后配置key&secret, 见下面.
   2.  [python social auth settings](https://python-social-auth.readthedocs.io/en/latest/configuration/settings.html)
       ~~~python
         # settings.py
         SOCIAL_AUTH_LINKEDIN_OAUTH2_KEY = '77xqioxxxxxxxx'
         SOCIAL_AUTH_LINKEDIN_OAUTH2_SECRET = 'zILxe7jcxxxxxxxx'
         SOCIAL_AUTH_LOGIN_REDIRECT_URL = '/home/'
         SOCIAL_AUTH_LOGIN_URL = '/'

       ~~~
10.

# Django shell
Django shell是和rails console类似的东西. Django的manage工具提供了shell命令，帮助我们配置好当前工程的运行环境（如连接好数据库等），以便可以直接在终端中执行测试python语句。

1. 打开Django shell: `python manage.py shell`
2. 导入需要的类型: `from exchange_rate.models import ExchangeRate`
3. 查看指定模型的所有记录: `ExchangeRate.objects.all()`
3. 查看指定模型的所有记录的数据: `ExchangeRate.objects.all().values()`
4. 计数: `ExchangeRate.objects.all().count()`
5. 查找指定的记录: `ExchangeRate.objects.get(id=1)`
6. 筛选: `ExchangeRate.objects.filter(author='xxx')`
7. 创建model object:
   1. `er = ExchangeRate(name='xxx');er.save()`
   2. `ExchangeRate.objects.create(name='xxx')`
8. 删除object: `ExchangeRate.objects.filter(id='xxx').delete()`

# Jupyter notebook
django extensions 支持notebook

1. 安装依赖: `pip install jupyter`, `pip install ipython`
2. 启动notebook: `./manage.py shell_plus --notebook`
# Django admin
django-admin.py是Django的一个用于管理任务的命令行工具，manage.py是对django-admin.py的简单包装，每个Django Project里面都会包含一个manage.py.

查看有那些命令: `python manage.py help`

## 常用子命令：

1. startproject:创建一个项目（*）
1. startapp:创建一个app（*）
1. runserver：运行开发服务器（*）
1. shell：进入django shell（*）
1. dbshell：进入django dbshell
1. check：检查django项目完整性
1. flush：清空数据库
1. compilemessages：编译语言文件
1. makemessages：创建语言文件
1. makemigrations：生成数据库同步脚本（*）
1. migrate：同步数据库（*）
1. showmigrations：查看生成的数据库同步脚本（*）
1. sqlflush：查看生成清空数据库的脚本（*）
1. sqlmigrate：查看数据库同步的sql语句（*）
1. dumpdata:导出数据
1. loaddata:导入数据
1. diffsettings:查看你的配置和django默认配置的不同之处

## manage.py特有的一些子命令:
1. createsuperuser:创建超级管理员（*）
1. changepassword:修改密码（*）
1. clearsessions：清除session


# Django extensions
[Django extensions](https://github.com/django-extensions/django-extensions) 是django admin的扩展。

1. show urls: `./manage.py show_urls`
2. shell plus: `./manage.py shell_plus`
3. 运行脚本, django extension自动导入django配置:
   1. 在项目根目录下，创建script文件夹: `mkdir scripts && touch scripts/__init__.py`
   2. 创建一个脚本文件: `touch scripts/delete_all_questions.py`
   3. 再次，写脚本。注：代码必须写在 run() 函数下。
	   ~~~py
		# scripts/delete_all_questions.py

		from polls.models import Question

		def run():
			# Fetch all questions
			questions = Question.objects.all()
			# Delete questions
			questions.delete()
		~~~
   4. 最后，运行脚本
		~~~sh
		  python manage.py runscript delete_all_questions
        python manage.py runscript delete_all_questions --traceback # 开启 Debug 模式
		~~~
1. 启动jupyter notebook: `./manage.py shell_plus --notebook`
   1. 需要安装依赖: `pip install jupyter && pip install ipython`

# Http

1. 返回json数据
   把数据库记录打包成json格式返回.

   ~~~python
    @action(methods=['GET'], detail=False)
    def index(self, request):
        start = request.query_params.get('start_at')
        if not start:
            start = datetime.now() - timedelta(days=30) # by default, start from 30 days before

        end = request.query_params.get('end_at')
        if not end or start >= end:
            end = datetime.now()
        print("querying exchange rate from {} to {}".format(start, end))
        exchanges = ExchangeRate.objects.filter(timestamp__range=[start, end]).all()
        serializer_class = ExchangeRateSerializer
        data = serializers.serialize('json', exchanges)

        return HttpResponse(data, content_type='application/json')
	~~~
1. 返回json数据
   把hash打包成json格式返回.
   ~~~python
        ret = { a: 'bbb'}
        return HttpResponse(json.dumps(ret), content_type='application/json;charset=utf8')
   ~~~


# Python Env

django的很多库对Python版本敏感。建议用conda指定python小版本创建env。
# refs
1. [Django/Rails cheat sheet](https://yeraydiazdiaz.medium.com/django-rails-cheat-sheet-50adf2441913)
2. [Django 开发利器 django-extensions](https://jiaxin.im/blog/django-kai-fa-li-qi-django-ext/)
3. [Django Best Practice: Settings file for multiple environments](https://medium.com/@ayarshabeer/django-best-practice-settings-file-for-multiple-environments-6d71c6966ee2)
